{
  "hash": "5d3f1d6c7c2cad973a4aa7e9f5983332",
  "result": {
    "markdown": "---\ntitle: \"Nginx proxy manager\"\ndate: \"2023-2-28\"\ncategories: [nix, linux, devops, nginx]\nexecute:\n  freeze: auto\n---\n\n# What is NPM and why do I want to use it?\n\nNginx proxy manager (npm, but not the node one) is a web based frontend for nginx that automatically also configures letsencrypt, similar to how certbot does it. It makes nginx much easier to use. Rather than writing config files, you can just click around, which is much easier. For a high school computer science class, I think NPM is better, because it doesn't have the complexity of npm (less potential for accidental failurs), but still teaches people about ports mapping, encryption, and other necessary skills. \n\nIn addition to that, with npm, even if someone does create a bad config, only their server goes down. With npm, a bad nginx config leads to the whole server going down. That is... not optimal.\n\n# Installation and Setup\n\nInstallation is simpleish. \n\nFirst, create a docker network for usage with our docker containers ([step from here](https://nginxproxymanager.com/advanced-config/#best-practice-use-a-docker-network)). Because these are our school projects, I will call that network `nighthawks`\n\n`docker network create nighthawks`\n\n\nCreate a folder called npm, and put a docker-compose.yml in it ([basic compose file from here](https://nginxproxymanager.com/guide/#quick-setup)):\n\n\n```{yaml}\nversion: '3'\nservices:\n  app:\n    image: 'jc21/nginx-proxy-manager:latest'\n    restart: unless-stopped\n    ports:\n      - '80:80'\n      - '81:81'\n      - '443:443'\n    volumes:\n      - ./data:/data\n      - ./letsencrypt:/etc/letsencrypt\n\nnetworks:\n  default:\n    external: true\n    name: nighthawks\n\n```\n\n\n`docker-compose up -d` and you're good to go. It should be noted that you need to have ports 443 and 80 unused by anything else, like Nginx proper. So if you are running nginx, stop it first before you up NPM.\n\nNPM does need to have port 81 accessible. \n\nYou can either use a reverse proxy, or open up the port to be accessible from the internet.\n\nIf you want the port to be accessible from the internet, you might have a firewall of some kind, so just open that. And if you are using one of the big cloud providers (aws, azure, oracle), then you also might have to configure security control groups, as that acts as an extra firewall for those server types. See my cockpit guide on how to do this with AWS. \n\nIf you want to do a reverse proxy, just use npm to do it: Use proxy post to connect http://npm_app_1:81 to a domain name.\n\n\nNow, to configure npm, just access the web interface at https://[domainname/ip]:81\n\n# Usage\n\nYou may notice above, in the section about using a reverse to expose npm, I use the docker container name, rather than a port. That's the amazing part of npm. As long as your docker containers are on the same network, all you need is a hostname and the used port. You don't even need to expose ports in your docker-compose.yml\n\nSo rather than the docker-compose.yml we use in our [deployment guide](https://nighthawkcoders.github.io/APCSP/techtalk/deploy#running-docker-using-docker-composeyml)\n\nWe can use: \n\n\n```{yaml}\n\n\n\nversion: '3'\nservices:\n      web:\n              image: flask_port_v1\n              build: .\n              #ports: # ports section not needed\n                     # - \"8086:8080\"\n              volumes:\n                      - persistent_volume:/app/volumes\nvolumes:\npersistent_volume:\n  driver: local\n  driver_opts:\n    o: bind\n    type: none\n    device: /home/ubuntu/flask_portfolio/volumes\n    # replace just flask_portfolio\n\nnetworks:\n  default:\n    external: true\n    name: nighthawks\n\n```\n\n\nAnd then you can simply expose http://flask_port_v1_web_1:8080 to the world!\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}